#include <algorithm>
#include <memory>

#include "new_and_delete.hh"

class Vector
{
public:
    Vector() = default;

    explicit Vector(std::vector<int>&& data)
        : data_( std::move(data) )
    {}

    void set_data(const std::vector<int>& data)
    {
        data_ = data;
    }
/*
    void set_data(std::vector<int>&& data)
    {
        // here data is not an rvalue any more because it has a name
        data_ = std::move(data);
    }
*/
private:
    std::vector<int> data_;
};


std::vector<int> create_vector()
{
    return std::vector<int>(200,73);
}


class NonCopyable
{
public:
    NonCopyable() = default;

    NonCopyable(const NonCopyable&) = delete;
    NonCopyable& operator=(const NonCopyable&) = delete;

    NonCopyable(NonCopyable&&) = default;
    NonCopyable& operator=(NonCopyable&&) = default;
};

bool operator<(const NonCopyable&,const NonCopyable&)
{
    return false;
}

#include "overloading_member_functions_using_reference_qualifiers.hh"


int main()
{
    // New reference declarator '&&'
    // Allows to distinguish between lvalues and rvalues, i.e.
    // values that can be on the left side of '=' and values that only can be on the right hand side
    int a = 42;

    int& b = a;     // b is an lvalue reference

    int&& c = 73;   // c is an lvalue reference, but has rvalue reference type,
                    // 73 is an rvalue (rule of thumb, rvalues are objects for which you cannot take the address)

    // We can make a rvalue reference out of c
    int&& d = std::move(c);

    // std::move does not move anything but casts, i.e.
    int&& e = static_cast<int&&>(d);


    // Use case: we can steal resources, mainly from temporaries, instead of copying them.
    std::vector<int> initial_object = create_vector();
    std::cout << "After initialization: initial_object.size() = " << initial_object.size() << '\n';

    std::vector<int> big_object = std::move(initial_object);
    std::cout << "After move-operation: initial_object.size() = " << initial_object.size() << '\n';
    std::cout << "After move-operation: big_object.size() = " << big_object.size() << end_block;


    {
        reset_heap_allocations();
        std::vector<int> other(big_object);
        std::cout << "Heap allocations (copy): " << heap_allocations() << '\n';
    }

    {
        reset_heap_allocations();
        std::vector<int> other(std::move(big_object));
        std::cout << "Heap allocations (move): " << heap_allocations() << '\n';
    }

    {
        const auto& other_big_object = create_vector();
        reset_heap_allocations();
        std::vector<int> other(std::move(other_big_object));
        std::cout << "Heap allocations (move from const): " << heap_allocations() << end_block;
    }


    {
        reset_heap_allocations();
        // About a myth from high performance computing: This does not save a copy
        const std::vector<int>& v = create_vector();

        std::cout << "Memory allocations for 'const std::vector<int>& v = create_vector(): "
                  << heap_allocations() << '\n';
        reset_heap_allocations();

        // compared to
        std::vector<int> w = create_vector();

        std::cout << "Memory allocations for 'std::vector<int> w = create_vector(): "
                  << heap_allocations() << '\n';

        // In most cases this is not related to C++11's move-semantics, but
        // to (possibly named) return value optimization.

        // But ...
        Vector vec;

        reset_heap_allocations();
        vec.set_data( create_vector() );
        std::cout << "Heap allocations for 'vec.set_data( create_vector() ): " << heap_allocations() << end_block;
    }

    {
        // Move semantics admit to work with objects that can not be copied.
        // I.e. we can sort-noncopyable types
        std::vector<NonCopyable> noncopyable_vec;
        for(auto i=0; i<100; ++i)
            noncopyable_vec.emplace_back();

        std::sort( begin(noncopyable_vec), end(noncopyable_vec) );
    }

/*
    {
        // Move semantics make clear when transfer of ownership happens
        std::vector<int> vec = create_vector();
        Vector my_vector( std::move(vec) );
    }
*/
    //    overloading_member_functions_using_reference_qualifiers();
}

// Special member function generation

namespace cpp98
{
    // Special member functions (possibly generated by the compiler).
    class Vector
    {
    public:
        /* Default constructor
         *
         * Generated if there is no user-declared constructor.
         */
        Vector();

        /* Destructor
         *
         * Generated if there is no user-declared destructor.
         */
        ~Vector();

        /* Copy constructor
         *
         * Generated if there is no user-declared copy-constructor.
         */
        Vector(const Vector&);

        /* Copy-assignment operator
         *
         * Generated if there is no user-declared copy-assignment operator.
         */
        Vector& operator=(const Vector&);
    };

    /* The rule of three
     *
     * If you declare any one of copy constructor, copy assignment or destructor, then declare all three.
     */
}

namespace cpp11
{
    // Special member functions (possibly generated by the compiler).
    class Vector
    {
    public:
        /* Default constructor
         *
         * Generated if there is no user-declared constructor.
         */
        Vector();

        /* Destructor
         *
         * Generated if there is no user-declared destructor.
         */
        ~Vector();

        /* Copy constructor
         *
         * Generated if there is no user-declared copy-constructor or move-operation.
         */
        Vector(const Vector&);

        /* Copy-assignment operator
         *
         * Generated if there is no user-declared copy-assignment operator or move operation.
         */
        Vector& operator=(const Vector&);

        /* Move constructor
         *
         * Generated if there is no user-declared destructor, copy-operation or move-operation.
         */
        Vector(Vector&&);

        /* Move-assignment operator
         *
         * Generated if there is no user-declared destructor, copy-operation or move-operation.
         */
        Vector& operator=(Vector&&);
    };

    /* The rule of five
     *
     * If you declare any one of copy or move constructor, copy or move assignment or destructor, then declare all five.
     */
}
